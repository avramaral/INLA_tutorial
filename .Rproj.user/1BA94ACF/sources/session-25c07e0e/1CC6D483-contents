library("INLA")
library("tidyverse")
library("sf")
library("raster")
library("patchwork")

custom_theme <-  theme_bw() + theme(legend.position = "right", 
                                    text = element_text(size = 14, family = "LM Roman 10"),
                                    plot.title = element_text(size = 16),
                                    legend.title = element_text(size = 12))

create_prediction_grid <- function (loc, resolution = 25, ...) {
  resolution <- 25 
  pts_bdy <- loc$geometry[[1]][[1]]
  pts_bdy_x <- range(pts_bdy[, 1])
  pts_bdy_y <- range(pts_bdy[, 2])
  coord_pred <- expand.grid(x = seq(pts_bdy_x[1], pts_bdy_x[2], by = resolution), y = seq(pts_bdy_y[1], pts_bdy_y[2], by = resolution))
  coordinates(coord_pred) <- ~ x + y
  
  xx <- as(st_as_sf(coord_pred), "sf");   st_crs(xx) <- st_crs(loc$geometry)
  yy <- as(st_as_sf(loc$geometry), "sf"); st_crs(yy) <- st_crs(loc$geometry)
  
  # Compute intersection between grid and `loc` borders
  pppts <- st_intersection(x = xx, y = yy)
  
  coord_pred <- matrix(data = NA, nrow = length(pppts$geometry), ncol = 2)
  colnames(coord_pred) <- c("x", "y")
  for (p in 1:length(pppts$geometry)) { coord_pred[p, ] <- sf::st_coordinates(pppts$geometry[[p]]) }
  coord_pred <- data.frame(x = coord_pred[, 1], y = coord_pred[, 2])
  
  as.matrix(coord_pred)
}

plot_pred_USA <- function (fitted_values, USA, r, tt = "", ...) {
  
  coordinates(fitted_values) <- ~ x + y
  gridded(fitted_values) <- TRUE
  fitted_values <- raster(fitted_values)
  crs(fitted_values) <- "+init=epsg:6345 +units=km +no_defs"
  
  fitted_values    <- as(fitted_values, "SpatialPixelsDataFrame")
  fitted_values_df <- as.data.frame(fitted_values)
  colnames(fitted_values_df) <- c("pred", "x", "y")
  
  breaks <- seq(floor(r[1]), ceiling(r[2]), length.out = 5)
  pp <- ggplot() +
    geom_tile(data = fitted_values_df, mapping = aes(x = x, y = y, fill = pred)) + 
    geom_sf(data = USA, color = "black", fill = NA, lwd = 0.5) +
    scale_fill_gradientn(name = "PM2.5", colors = rainbow(9, start = 0.1, end = 0.9), breaks = breaks, limits = c(breaks[1], tail(breaks, 1))) + 
    labs(x = "", y = "", title = tt) + 
    custom_theme + 
    theme(axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks  = element_blank())
  
  pp
} 

##################################################
##################################################

data_USA <- readRDS(file = "data/example_4/data_USA.rds")
USA <- readRDS(file = "data/example_4/USA_filtered.rds")

ggplot() + 
  geom_sf(data = USA, fill = "white") +
  geom_sf(data = data_USA, aes(fill = mean), color = "black", size = 3, shape = 21) +
  scale_fill_gradientn(name = "PM2.5 level", colors = rainbow(9, start = 0.1, end = 0.9)) + 
  labs(x = "", y = "", title = "") +
  custom_theme + 
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks  = element_blank())


# Boundary coordinates
USA_coor <- sf::st_coordinates(USA)
USA_coor <- matrix(c(USA_coor[, 1], USA_coor[, 2]), ncol = 2)
colnames(USA_coor) <- c("lon", "lat")

# Points coordinates
data_coor <- sf::st_coordinates(data_USA)
data_USA  <- bind_cols(data_USA, as_tibble(data_coor))
data_USA  <- data_USA %>% rename(lon = X, lat = Y) %>% dplyr::select(mean, sd, lon, lat, geometry)

# `max.edge`: the largest allowed triangle edge length. One or two values.
# `offset`: the automatic extension distance. One or two values, for an inner and an optional outer extension.

mesh <- inla.mesh.2d(loc.domain = USA_coor, max.edge = c(300, 3000), offset = c(300, 1500))
saveRDS(object = mesh, file = "data/example_4/mesh.RDS")

mesh$n # Number of nodes

# Plot `mesh`
{ 
  plot(mesh)
  plot(USA$geometry, lwd = 2, border = "red", add = TRUE)
  points(data_USA$lon, data_USA$lat, pch = 1, col = "green") 
}


# Building the SPDE model
# alpha = nu + d / 2 = 1 + 1 = 2, for nu = 1

# Flexible parameterization (with a default one)
# spde <- inla.spde2.matern(mesh = mesh, alpha = 2)
# Parameterization for PC priors
spde <- inla.spde2.pcmatern(mesh = mesh, 
                            alpha = 2,
                            prior.range = c(1e3, 0.90), # P(range < 1e3) = 0.90
                            prior.sigma = c(1.0, 0.01)) # P(sigma > 1.0) = 0.01

# Indices
indxs <- inla.spde.make.index("s", spde$n.spde)
# Projection matrix
A <- inla.spde.make.A(mesh = mesh, loc = data_coor)

# Prediction
coord_pred <- create_prediction_grid(USA)
saveRDS(object = coord_pred, file = "data/example_4/coord_pred.RDS")
{
  coord_pred_cp <- as.data.frame(coord_pred)
  coordinates(coord_pred_cp) <- ~ x + y
  plot(coord_pred_cp)
}

# Projection matrix for prediction
Ap <- inla.spde.make.A(mesh = mesh, loc = coord_pred)

# Create stacks
# Stack for estimation 
stk_e <- inla.stack(tag = "est",
                    data = list(y = data_USA$mean),
                    A = list(1, A),
                    effects = list(data.frame(b0 = rep(1, nrow(data_USA))), s = indxs))

# Stack for prediction
stk_p <- inla.stack(tag = "pred",
                    data = list(y = NA),
                    A = list(1, Ap),
                    effects = list(data.frame(b0 = rep(1, nrow(coord_pred))), s = indxs))

# Full stack
stk_full <- inla.stack(stk_e, stk_p)

# Fit model
formula_1 <- y ~ 0 + b0 + f(s, model = spde)

model_4_1 <- inla(formula = formula_1,
                  family  = "gaussian", 
                  data = inla.stack.data(stk_full), 
                  control.predictor = list(compute = TRUE,
                                           A = inla.stack.A(stk_full))) # Matrix of predictors

saveRDS(object = model_4_1, file = "models/model_4_1.RDS")

summary(model_4_1)

# Posteriors

ss <- inla.tmarginal(fun = function(x) { 1 / sqrt(x) }, marginal = model_4_1$marginals.hyperpar$`Precision for the Gaussian observations`)

ggplot(data.frame(inla.smarginal(ss))) +
  geom_line(aes(x, y)) +
  labs(x = "", y = "", title = "Posterior of the standard deviation for the observations") + 
  custom_theme

ggplot(data.frame(inla.smarginal(model_4_1$marginals.hyperpar$`Range for s`))) +
  geom_line(aes(x, y)) +
  labs(x = "", y = "", title = "Posterior of the range in the Matérn model") + 
  custom_theme

ggplot(data.frame(inla.smarginal(model_4_1$marginals.hyperpar$`Stdev for s`))) +
  geom_line(aes(x, y)) +
  labs(x = "", y = "", title = "Posterior of the standard deviation in the Matérn model") + 
  custom_theme

# According to this parameterization: https://becarioprecario.bitbucket.io/spde-gitbook/ch-intro.html#sec:matern
# range = sqrt(8 * smoothness) / scale

# Fitted values and prediction
idxs_pred <- inla.stack.index(stk_full, tag = "pred")$data

pred_mm <- as.data.frame(cbind(coord_pred, model_4_1$summary.fitted.values[idxs_pred, "mean"]))
pred_ll <- as.data.frame(cbind(coord_pred, model_4_1$summary.fitted.values[idxs_pred, "0.025quant"]))
pred_uu <- as.data.frame(cbind(coord_pred, model_4_1$summary.fitted.values[idxs_pred, "0.975quant"]))

r_mm <- pred_mm$V3 %>% range()
r_ll <- pred_ll$V3 %>% range()
r_uu <- pred_uu$V3 %>% range()
r <- c(min(r_mm[1], r_ll[1], r_uu[1]), max(r_mm[2], r_ll[2], r_uu[2]))

pp_mm <- plot_pred_USA(fitted_values = pred_mm, USA = USA, r = r, tt = "Posterior Mean")
pp_ll <- plot_pred_USA(fitted_values = pred_ll, USA = USA, r = r, tt = "Posterior  2.5th percentile")
pp_uu <- plot_pred_USA(fitted_values = pred_uu, USA = USA, r = r, tt = "Posterior 97.5th percentile")

(pp_ll + pp_mm + pp_uu) + plot_layout(guides = "collect") & theme(legend.position = "right")
